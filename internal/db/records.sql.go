// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: records.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRecords = `-- name: CountRecords :one
SELECT COUNT(*) FROM records
`

func (q *Queries) CountRecords(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRecords)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecordsByArtist = `-- name: CountRecordsByArtist :one
SELECT COUNT(*) FROM records WHERE artist_id = $1
`

func (q *Queries) CountRecordsByArtist(ctx context.Context, artistID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countRecordsByArtist, artistID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecordsByLocation = `-- name: CountRecordsByLocation :one
SELECT COUNT(*) FROM records WHERE current_location_id = $1
`

func (q *Queries) CountRecordsByLocation(ctx context.Context, currentLocationID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countRecordsByLocation, currentLocationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRecord = `-- name: CreateRecord :one
INSERT INTO records (
    title, artist_id, album_title, release_year, 
    current_location_id, home_location_id, catalog_number, 
    condition, notes, play_count
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

type CreateRecordParams struct {
	Title             string      `json:"title"`
	ArtistID          pgtype.Int4 `json:"artist_id"`
	AlbumTitle        pgtype.Text `json:"album_title"`
	ReleaseYear       pgtype.Int4 `json:"release_year"`
	CurrentLocationID pgtype.Int4 `json:"current_location_id"`
	HomeLocationID    pgtype.Int4 `json:"home_location_id"`
	CatalogNumber     pgtype.Text `json:"catalog_number"`
	Condition         pgtype.Text `json:"condition"`
	Notes             pgtype.Text `json:"notes"`
	PlayCount         pgtype.Int4 `json:"play_count"`
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (Record, error) {
	row := q.db.QueryRow(ctx, createRecord,
		arg.Title,
		arg.ArtistID,
		arg.AlbumTitle,
		arg.ReleaseYear,
		arg.CurrentLocationID,
		arg.HomeLocationID,
		arg.CatalogNumber,
		arg.Condition,
		arg.Notes,
		arg.PlayCount,
	)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRecord = `-- name: DeleteRecord :exec
DELETE FROM records
WHERE id = $1
`

func (q *Queries) DeleteRecord(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRecord, id)
	return err
}

const getMostPlayedRecords = `-- name: GetMostPlayedRecords :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE play_count > 0
ORDER BY play_count DESC
LIMIT $1
`

func (q *Queries) GetMostPlayedRecords(ctx context.Context, limit int32) ([]Record, error) {
	rows, err := q.db.Query(ctx, getMostPlayedRecords, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyPlayedRecords = `-- name: GetRecentlyPlayedRecords :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE last_played_at IS NOT NULL
ORDER BY last_played_at DESC
LIMIT $1
`

func (q *Queries) GetRecentlyPlayedRecords(ctx context.Context, limit int32) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecentlyPlayedRecords, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecord = `-- name: GetRecord :one
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE id = $1
`

func (q *Queries) GetRecord(ctx context.Context, id int32) (Record, error) {
	row := q.db.QueryRow(ctx, getRecord, id)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecordWithDetails = `-- name: GetRecordWithDetails :one
SELECT r.id, r.title, r.album_title, r.release_year, 
       r.catalog_number, r.condition, r.notes, 
       r.last_played_at, r.play_count, r.created_at, r.updated_at,
       a.id as artist_id, a.name as artist_name,
       cl.id as current_location_id, cl.name as current_location_name,
       hl.id as home_location_id, hl.name as home_location_name
FROM records r
LEFT JOIN artists a ON r.artist_id = a.id
LEFT JOIN locations cl ON r.current_location_id = cl.id
LEFT JOIN locations hl ON r.home_location_id = hl.id
WHERE r.id = $1
`

type GetRecordWithDetailsRow struct {
	ID                  int32              `json:"id"`
	Title               string             `json:"title"`
	AlbumTitle          pgtype.Text        `json:"album_title"`
	ReleaseYear         pgtype.Int4        `json:"release_year"`
	CatalogNumber       pgtype.Text        `json:"catalog_number"`
	Condition           pgtype.Text        `json:"condition"`
	Notes               pgtype.Text        `json:"notes"`
	LastPlayedAt        pgtype.Timestamptz `json:"last_played_at"`
	PlayCount           pgtype.Int4        `json:"play_count"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	ArtistID            pgtype.Int4        `json:"artist_id"`
	ArtistName          pgtype.Text        `json:"artist_name"`
	CurrentLocationID   pgtype.Int4        `json:"current_location_id"`
	CurrentLocationName pgtype.Text        `json:"current_location_name"`
	HomeLocationID      pgtype.Int4        `json:"home_location_id"`
	HomeLocationName    pgtype.Text        `json:"home_location_name"`
}

func (q *Queries) GetRecordWithDetails(ctx context.Context, id int32) (GetRecordWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getRecordWithDetails, id)
	var i GetRecordWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ArtistID,
		&i.ArtistName,
		&i.CurrentLocationID,
		&i.CurrentLocationName,
		&i.HomeLocationID,
		&i.HomeLocationName,
	)
	return i, err
}

const getRecordsByArtist = `-- name: GetRecordsByArtist :many
SELECT r.id, r.title, r.artist_id, r.album_title, r.release_year, 
       r.current_location_id, r.home_location_id, r.catalog_number, 
       r.condition, r.notes, r.last_played_at, r.play_count, 
       r.created_at, r.updated_at
FROM records r
WHERE r.artist_id = $1
ORDER BY r.title ASC
`

func (q *Queries) GetRecordsByArtist(ctx context.Context, artistID pgtype.Int4) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsByArtist, artistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByCondition = `-- name: GetRecordsByCondition :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE condition = $1
ORDER BY title ASC
`

func (q *Queries) GetRecordsByCondition(ctx context.Context, condition pgtype.Text) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsByCondition, condition)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByLocation = `-- name: GetRecordsByLocation :many
SELECT r.id, r.title, r.artist_id, r.album_title, r.release_year, 
       r.current_location_id, r.home_location_id, r.catalog_number, 
       r.condition, r.notes, r.last_played_at, r.play_count, 
       r.created_at, r.updated_at
FROM records r
WHERE r.current_location_id = $1
ORDER BY r.title ASC
`

func (q *Queries) GetRecordsByLocation(ctx context.Context, currentLocationID pgtype.Int4) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsByLocation, currentLocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByReleaseYear = `-- name: GetRecordsByReleaseYear :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE release_year = $1
ORDER BY title ASC
`

func (q *Queries) GetRecordsByReleaseYear(ctx context.Context, releaseYear pgtype.Int4) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsByReleaseYear, releaseYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecords = `-- name: ListRecords :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
ORDER BY title ASC
`

func (q *Queries) ListRecords(ctx context.Context) ([]Record, error) {
	rows, err := q.db.Query(ctx, listRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsWithDetails = `-- name: ListRecordsWithDetails :many
SELECT r.id, r.title, r.album_title, r.release_year, 
       r.catalog_number, r.condition, r.notes, 
       r.last_played_at, r.play_count, r.created_at, r.updated_at,
       a.id as artist_id, a.name as artist_name,
       cl.id as current_location_id, cl.name as current_location_name,
       hl.id as home_location_id, hl.name as home_location_name
FROM records r
LEFT JOIN artists a ON r.artist_id = a.id
LEFT JOIN locations cl ON r.current_location_id = cl.id
LEFT JOIN locations hl ON r.home_location_id = hl.id
ORDER BY r.title ASC
`

type ListRecordsWithDetailsRow struct {
	ID                  int32              `json:"id"`
	Title               string             `json:"title"`
	AlbumTitle          pgtype.Text        `json:"album_title"`
	ReleaseYear         pgtype.Int4        `json:"release_year"`
	CatalogNumber       pgtype.Text        `json:"catalog_number"`
	Condition           pgtype.Text        `json:"condition"`
	Notes               pgtype.Text        `json:"notes"`
	LastPlayedAt        pgtype.Timestamptz `json:"last_played_at"`
	PlayCount           pgtype.Int4        `json:"play_count"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	ArtistID            pgtype.Int4        `json:"artist_id"`
	ArtistName          pgtype.Text        `json:"artist_name"`
	CurrentLocationID   pgtype.Int4        `json:"current_location_id"`
	CurrentLocationName pgtype.Text        `json:"current_location_name"`
	HomeLocationID      pgtype.Int4        `json:"home_location_id"`
	HomeLocationName    pgtype.Text        `json:"home_location_name"`
}

func (q *Queries) ListRecordsWithDetails(ctx context.Context) ([]ListRecordsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listRecordsWithDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecordsWithDetailsRow{}
	for rows.Next() {
		var i ListRecordsWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArtistID,
			&i.ArtistName,
			&i.CurrentLocationID,
			&i.CurrentLocationName,
			&i.HomeLocationID,
			&i.HomeLocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsWithPagination = `-- name: ListRecordsWithPagination :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
ORDER BY title ASC
LIMIT $1 OFFSET $2
`

type ListRecordsWithPaginationParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRecordsWithPagination(ctx context.Context, arg ListRecordsWithPaginationParams) ([]Record, error) {
	rows, err := q.db.Query(ctx, listRecordsWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordPlayback = `-- name: RecordPlayback :one
UPDATE records
SET last_played_at = CURRENT_TIMESTAMP, play_count = play_count + 1
WHERE id = $1
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

func (q *Queries) RecordPlayback(ctx context.Context, id int32) (Record, error) {
	row := q.db.QueryRow(ctx, recordPlayback, id)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchRecordsByAlbum = `-- name: SearchRecordsByAlbum :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE album_title ILIKE '%' || $1 || '%'
ORDER BY album_title ASC
`

func (q *Queries) SearchRecordsByAlbum(ctx context.Context, dollar_1 pgtype.Text) ([]Record, error) {
	rows, err := q.db.Query(ctx, searchRecordsByAlbum, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRecordsByTitle = `-- name: SearchRecordsByTitle :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE title ILIKE '%' || $1 || '%'
ORDER BY title ASC
`

func (q *Queries) SearchRecordsByTitle(ctx context.Context, dollar_1 pgtype.Text) ([]Record, error) {
	rows, err := q.db.Query(ctx, searchRecordsByTitle, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecord = `-- name: UpdateRecord :one
UPDATE records
SET title = $2, artist_id = $3, album_title = $4, release_year = $5,
    current_location_id = $6, home_location_id = $7, catalog_number = $8,
    condition = $9, notes = $10
WHERE id = $1
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

type UpdateRecordParams struct {
	ID                int32       `json:"id"`
	Title             string      `json:"title"`
	ArtistID          pgtype.Int4 `json:"artist_id"`
	AlbumTitle        pgtype.Text `json:"album_title"`
	ReleaseYear       pgtype.Int4 `json:"release_year"`
	CurrentLocationID pgtype.Int4 `json:"current_location_id"`
	HomeLocationID    pgtype.Int4 `json:"home_location_id"`
	CatalogNumber     pgtype.Text `json:"catalog_number"`
	Condition         pgtype.Text `json:"condition"`
	Notes             pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateRecord(ctx context.Context, arg UpdateRecordParams) (Record, error) {
	row := q.db.QueryRow(ctx, updateRecord,
		arg.ID,
		arg.Title,
		arg.ArtistID,
		arg.AlbumTitle,
		arg.ReleaseYear,
		arg.CurrentLocationID,
		arg.HomeLocationID,
		arg.CatalogNumber,
		arg.Condition,
		arg.Notes,
	)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRecordCondition = `-- name: UpdateRecordCondition :one
UPDATE records
SET condition = $2
WHERE id = $1
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

type UpdateRecordConditionParams struct {
	ID        int32       `json:"id"`
	Condition pgtype.Text `json:"condition"`
}

func (q *Queries) UpdateRecordCondition(ctx context.Context, arg UpdateRecordConditionParams) (Record, error) {
	row := q.db.QueryRow(ctx, updateRecordCondition, arg.ID, arg.Condition)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRecordLocation = `-- name: UpdateRecordLocation :one
UPDATE records
SET current_location_id = $2
WHERE id = $1
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

type UpdateRecordLocationParams struct {
	ID                int32       `json:"id"`
	CurrentLocationID pgtype.Int4 `json:"current_location_id"`
}

func (q *Queries) UpdateRecordLocation(ctx context.Context, arg UpdateRecordLocationParams) (Record, error) {
	row := q.db.QueryRow(ctx, updateRecordLocation, arg.ID, arg.CurrentLocationID)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
