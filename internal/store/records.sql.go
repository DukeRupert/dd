// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: records.sql

package store

import (
	"context"
	"database/sql"
)

const countRecords = `-- name: CountRecords :one
SELECT COUNT(*) FROM records
`

func (q *Queries) CountRecords(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecords)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecordsByArtist = `-- name: CountRecordsByArtist :one
SELECT COUNT(*) FROM records WHERE artist_id = ?
`

func (q *Queries) CountRecordsByArtist(ctx context.Context, artistID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecordsByArtist, artistID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecordsByLocation = `-- name: CountRecordsByLocation :one
SELECT COUNT(*) FROM records WHERE current_location_id = ?
`

func (q *Queries) CountRecordsByLocation(ctx context.Context, currentLocationID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecordsByLocation, currentLocationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRecord = `-- name: CreateRecord :one
INSERT INTO records (
    title, artist_id, album_title, release_year, 
    current_location_id, home_location_id, catalog_number, 
    condition, notes, play_count
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

type CreateRecordParams struct {
	Title             string
	ArtistID          sql.NullInt64
	AlbumTitle        sql.NullString
	ReleaseYear       sql.NullInt64
	CurrentLocationID sql.NullInt64
	HomeLocationID    sql.NullInt64
	CatalogNumber     sql.NullString
	Condition         sql.NullString
	Notes             sql.NullString
	PlayCount         sql.NullInt64
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (Record, error) {
	row := q.db.QueryRowContext(ctx, createRecord,
		arg.Title,
		arg.ArtistID,
		arg.AlbumTitle,
		arg.ReleaseYear,
		arg.CurrentLocationID,
		arg.HomeLocationID,
		arg.CatalogNumber,
		arg.Condition,
		arg.Notes,
		arg.PlayCount,
	)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRecord = `-- name: DeleteRecord :exec
DELETE FROM records
WHERE id = ?
`

func (q *Queries) DeleteRecord(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRecord, id)
	return err
}

const getMostPlayedRecords = `-- name: GetMostPlayedRecords :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE play_count > 0
ORDER BY play_count DESC
LIMIT ?
`

func (q *Queries) GetMostPlayedRecords(ctx context.Context, limit int64) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, getMostPlayedRecords, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyPlayedRecords = `-- name: GetRecentlyPlayedRecords :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE last_played_at IS NOT NULL
ORDER BY last_played_at DESC
LIMIT ?
`

func (q *Queries) GetRecentlyPlayedRecords(ctx context.Context, limit int64) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, getRecentlyPlayedRecords, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecord = `-- name: GetRecord :one
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE id = ?
`

func (q *Queries) GetRecord(ctx context.Context, id int64) (Record, error) {
	row := q.db.QueryRowContext(ctx, getRecord, id)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecordWithDetails = `-- name: GetRecordWithDetails :one
SELECT r.id, r.title, r.album_title, r.release_year, 
       r.catalog_number, r.condition, r.notes, 
       r.last_played_at, r.play_count, r.created_at, r.updated_at,
       a.id as artist_id, a.name as artist_name,
       cl.id as current_location_id, cl.name as current_location_name,
       hl.id as home_location_id, hl.name as home_location_name
FROM records r
LEFT JOIN artists a ON r.artist_id = a.id
LEFT JOIN locations cl ON r.current_location_id = cl.id
LEFT JOIN locations hl ON r.home_location_id = hl.id
WHERE r.id = ?
`

type GetRecordWithDetailsRow struct {
	ID                  int64
	Title               string
	AlbumTitle          sql.NullString
	ReleaseYear         sql.NullInt64
	CatalogNumber       sql.NullString
	Condition           sql.NullString
	Notes               sql.NullString
	LastPlayedAt        sql.NullTime
	PlayCount           sql.NullInt64
	CreatedAt           sql.NullTime
	UpdatedAt           sql.NullTime
	ArtistID            sql.NullInt64
	ArtistName          sql.NullString
	CurrentLocationID   sql.NullInt64
	CurrentLocationName sql.NullString
	HomeLocationID      sql.NullInt64
	HomeLocationName    sql.NullString
}

func (q *Queries) GetRecordWithDetails(ctx context.Context, id int64) (GetRecordWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getRecordWithDetails, id)
	var i GetRecordWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ArtistID,
		&i.ArtistName,
		&i.CurrentLocationID,
		&i.CurrentLocationName,
		&i.HomeLocationID,
		&i.HomeLocationName,
	)
	return i, err
}

const getRecordsByArtist = `-- name: GetRecordsByArtist :many
SELECT r.id, r.title, r.artist_id, r.album_title, r.release_year, 
       r.current_location_id, r.home_location_id, r.catalog_number, 
       r.condition, r.notes, r.last_played_at, r.play_count, 
       r.created_at, r.updated_at
FROM records r
WHERE r.artist_id = ?
ORDER BY r.title ASC
`

func (q *Queries) GetRecordsByArtist(ctx context.Context, artistID sql.NullInt64) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, getRecordsByArtist, artistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByCondition = `-- name: GetRecordsByCondition :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE condition = ?
ORDER BY title ASC
`

func (q *Queries) GetRecordsByCondition(ctx context.Context, condition sql.NullString) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, getRecordsByCondition, condition)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByLocation = `-- name: GetRecordsByLocation :many
SELECT r.id, r.title, r.artist_id, r.album_title, r.release_year, 
       r.current_location_id, r.home_location_id, r.catalog_number, 
       r.condition, r.notes, r.last_played_at, r.play_count, 
       r.created_at, r.updated_at
FROM records r
WHERE r.current_location_id = ?
ORDER BY r.title ASC
`

func (q *Queries) GetRecordsByLocation(ctx context.Context, currentLocationID sql.NullInt64) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, getRecordsByLocation, currentLocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByReleaseYear = `-- name: GetRecordsByReleaseYear :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE release_year = ?
ORDER BY title ASC
`

func (q *Queries) GetRecordsByReleaseYear(ctx context.Context, releaseYear sql.NullInt64) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, getRecordsByReleaseYear, releaseYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecords = `-- name: ListRecords :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
ORDER BY title ASC
`

func (q *Queries) ListRecords(ctx context.Context) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, listRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsWithDetails = `-- name: ListRecordsWithDetails :many
SELECT r.id, r.title, r.album_title, r.release_year, 
       r.catalog_number, r.condition, r.notes, 
       r.last_played_at, r.play_count, r.created_at, r.updated_at,
       a.id as artist_id, a.name as artist_name,
       cl.id as current_location_id, cl.name as current_location_name,
       hl.id as home_location_id, hl.name as home_location_name
FROM records r
LEFT JOIN artists a ON r.artist_id = a.id
LEFT JOIN locations cl ON r.current_location_id = cl.id
LEFT JOIN locations hl ON r.home_location_id = hl.id
ORDER BY r.title ASC
`

type ListRecordsWithDetailsRow struct {
	ID                  int64
	Title               string
	AlbumTitle          sql.NullString
	ReleaseYear         sql.NullInt64
	CatalogNumber       sql.NullString
	Condition           sql.NullString
	Notes               sql.NullString
	LastPlayedAt        sql.NullTime
	PlayCount           sql.NullInt64
	CreatedAt           sql.NullTime
	UpdatedAt           sql.NullTime
	ArtistID            sql.NullInt64
	ArtistName          sql.NullString
	CurrentLocationID   sql.NullInt64
	CurrentLocationName sql.NullString
	HomeLocationID      sql.NullInt64
	HomeLocationName    sql.NullString
}

func (q *Queries) ListRecordsWithDetails(ctx context.Context) ([]ListRecordsWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecordsWithDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecordsWithDetailsRow
	for rows.Next() {
		var i ListRecordsWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArtistID,
			&i.ArtistName,
			&i.CurrentLocationID,
			&i.CurrentLocationName,
			&i.HomeLocationID,
			&i.HomeLocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsWithPagination = `-- name: ListRecordsWithPagination :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
ORDER BY title ASC
LIMIT ? OFFSET ?
`

type ListRecordsWithPaginationParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListRecordsWithPagination(ctx context.Context, arg ListRecordsWithPaginationParams) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, listRecordsWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordPlayback = `-- name: RecordPlayback :one
UPDATE records
SET last_played_at = CURRENT_TIMESTAMP, play_count = play_count + 1
WHERE id = ?
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

func (q *Queries) RecordPlayback(ctx context.Context, id int64) (Record, error) {
	row := q.db.QueryRowContext(ctx, recordPlayback, id)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchRecordsByAlbum = `-- name: SearchRecordsByAlbum :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE album_title LIKE '%' || ? || '%'
ORDER BY album_title ASC
`

func (q *Queries) SearchRecordsByAlbum(ctx context.Context, dollar_1 sql.NullString) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, searchRecordsByAlbum, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRecordsByTitle = `-- name: SearchRecordsByTitle :many
SELECT id, title, artist_id, album_title, release_year, 
       current_location_id, home_location_id, catalog_number, 
       condition, notes, last_played_at, play_count, 
       created_at, updated_at
FROM records
WHERE title LIKE '%' || ? || '%'
ORDER BY title ASC
`

func (q *Queries) SearchRecordsByTitle(ctx context.Context, dollar_1 sql.NullString) ([]Record, error) {
	rows, err := q.db.QueryContext(ctx, searchRecordsByTitle, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ArtistID,
			&i.AlbumTitle,
			&i.ReleaseYear,
			&i.CurrentLocationID,
			&i.HomeLocationID,
			&i.CatalogNumber,
			&i.Condition,
			&i.Notes,
			&i.LastPlayedAt,
			&i.PlayCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecord = `-- name: UpdateRecord :one
UPDATE records
SET title = ?, artist_id = ?, album_title = ?, release_year = ?,
    current_location_id = ?, home_location_id = ?, catalog_number = ?,
    condition = ?, notes = ?
WHERE id = ?
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

type UpdateRecordParams struct {
	Title             string
	ArtistID          sql.NullInt64
	AlbumTitle        sql.NullString
	ReleaseYear       sql.NullInt64
	CurrentLocationID sql.NullInt64
	HomeLocationID    sql.NullInt64
	CatalogNumber     sql.NullString
	Condition         sql.NullString
	Notes             sql.NullString
	ID                int64
}

func (q *Queries) UpdateRecord(ctx context.Context, arg UpdateRecordParams) (Record, error) {
	row := q.db.QueryRowContext(ctx, updateRecord,
		arg.Title,
		arg.ArtistID,
		arg.AlbumTitle,
		arg.ReleaseYear,
		arg.CurrentLocationID,
		arg.HomeLocationID,
		arg.CatalogNumber,
		arg.Condition,
		arg.Notes,
		arg.ID,
	)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRecordCondition = `-- name: UpdateRecordCondition :one
UPDATE records
SET condition = ?
WHERE id = ?
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

type UpdateRecordConditionParams struct {
	Condition sql.NullString
	ID        int64
}

func (q *Queries) UpdateRecordCondition(ctx context.Context, arg UpdateRecordConditionParams) (Record, error) {
	row := q.db.QueryRowContext(ctx, updateRecordCondition, arg.Condition, arg.ID)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRecordLocation = `-- name: UpdateRecordLocation :one
UPDATE records
SET current_location_id = ?
WHERE id = ?
RETURNING id, title, artist_id, album_title, release_year, 
          current_location_id, home_location_id, catalog_number, 
          condition, notes, last_played_at, play_count, 
          created_at, updated_at
`

type UpdateRecordLocationParams struct {
	CurrentLocationID sql.NullInt64
	ID                int64
}

func (q *Queries) UpdateRecordLocation(ctx context.Context, arg UpdateRecordLocationParams) (Record, error) {
	row := q.db.QueryRowContext(ctx, updateRecordLocation, arg.CurrentLocationID, arg.ID)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ArtistID,
		&i.AlbumTitle,
		&i.ReleaseYear,
		&i.CurrentLocationID,
		&i.HomeLocationID,
		&i.CatalogNumber,
		&i.Condition,
		&i.Notes,
		&i.LastPlayedAt,
		&i.PlayCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
